#!/usr/bin/env bash

cat<<EOF

Name:
  git-checkout - Switch branches or restore working tree files

------------------------------------------------------------------------------

Description:
  Updates files in the working tree to match the version in the index or the
  specified tree. If no paths are given, git checkout will also update HEAD to
  set the specified branch as the current branch.

------------------------------------------------------------------------------

Syntax:
  git checkout [-q] [-f] [-m] [<branch>]
  git checkout [-q] [-f] [-m] --detach [<branch>]
  git checkout [-q] [-f] [-m] [--detach] <commit>
  git checkout [-q] [-f] [-m] [[-b|-B|--orphan] <new_branch>] [<start_point>]
  git checkout [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <paths>…​
  git checkout [-p|--patch] [<tree-ish>] [--] [<paths>…​]

------------------------------------------------------------------------------

Options:
  -q
  --quiet
    Quiet, suppress feedback messages.

  --[no-]progress
    Progress status is reported on the standard error stream by default when it
    is attached to a terminal, unless --quiet is specified. This flag enables
    progress reporting even if not attached to a terminal, regardless of
    --quiet.

  -f
  --force
    When switching branches, proceed even if the index or the working tree
    differs from HEAD. This is used to throw away local changes.

    When checking out paths from the index, do not fail upon unmerged entries;
    instead, unmerged entries are ignored.

  --ours
  --theirs
    When checking out paths from the index, check out stage #2 (ours) or #3
    (theirs) for unmerged paths.

    Note that during git rebase and git pull --rebase, ours and theirs may
    appear swapped; --ours gives the version from the branch the changes are
    rebased onto, while --theirs gives the version from the branch that holds
    your work that is being rebased.

    This is because rebase is used in a workflow that treats the history at the
    remote as the shared canonical one, and treats the work done on the branch
    you are rebasing as the third-party work to be integrated, and you are
    temporarily assuming the role of the keeper of the canonical history during
    the rebase. As the keeper of the canonical history, you need to view the
    history from the remote as ours (i.e. "our shared canonical history"), while
    what you did on your side branch as theirs (i.e. "one contributor’s work on
    top of it").

  -b <new_branch>
    Create a new branch named <new_branch> and start it at <start_point>; see
    git-branch[1] for details.

  -B <new_branch>
    Creates the branch <new_branch> and start it at <start_point>; if it already
    exists, then reset it to <start_point>. This is equivalent to running "git
    branch" with "-f"; see git-branch[1] for details.

  -t
  --track
    When creating a new branch, set up "upstream" configuration. See "--track"
    in git-branch[1] for details.

    If no -b option is given, the name of the new branch will be derived from
    the remote-tracking branch, by looking at the local part of the refspec
    configured for the corresponding remote, and then stripping the initial part
    up to the "*". This would tell us to use "hack" as the local branch when
    branching off of "origin/hack" (or "remotes/origin/hack", or even
    "refs/remotes/origin/hack"). If the given name has no slash, or the above
    guessing results in an empty name, the guessing is aborted. You can
    explicitly give a name with -b in such a case.

  --no-track
    Do not set up "upstream" configuration, even if the branch.autoSetupMerge
    configuration variable is true.

  -l
    Create the new branch’s reflog; see git-branch[1] for details.

  --detach
    Rather than checking out a branch to work on it, check out a commit for
    inspection and discardable experiments. This is the default behavior of "git
    checkout <commit>" when <commit> is not a branch name. See the "DETACHED
    HEAD" section below for details.

  --orphan <new_branch>
    Create a new orphan branch, named <new_branch>, started from <start_point>
    and switch to it. The first commit made on this new branch will have no
    parents and it will be the root of a new history totally disconnected from
    all the other branches and commits.

    The index and the working tree are adjusted as if you had previously run
    "git checkout <start_point>". This allows you to start a new history that
    records a set of paths similar to <start_point> by easily running "git
    commit -a" to make the root commit.

    This can be useful when you want to publish the tree from a commit without
    exposing its full history. You might want to do this to publish an open
    source branch of a project whose current tree is "clean", but whose full
    history contains proprietary or otherwise encumbered bits of code.

    If you want to start a disconnected history that records a set of paths that
    is totally different from the one of <start_point>, then you should clear
    the index and the working tree right after creating the orphan branch by
    running "git rm -rf ." from the top level of the working tree. Afterwards
    you will be ready to prepare your new files, repopulating the working tree,
    by copying them from elsewhere, extracting a tarball, etc.

  --ignore-skip-worktree-bits
    In sparse checkout mode, git checkout -- <paths> would update only entries
    matched by <paths> and sparse patterns in \$GIT_DIR/info/sparse-checkout.
    This option ignores the sparse patterns and adds back any files in <paths>.

  -m
  --merge
    When switching branches, if you have local modifications to one or more
    files that are different between the current branch and the branch to which
    you are switching, the command refuses to switch branches in order to
    preserve your modifications in context. However, with this option,
    a three-way merge between the current branch, your working tree contents,
    and the new branch is done, and you will be on the new branch.

    When a merge conflict happens, the index entries for conflicting paths are
    left unmerged, and you need to resolve the conflicts and mark the resolved
    paths with git add (or git rm if the merge should result in deletion of the
    path).

    When checking out paths from the index, this option lets you recreate the
    conflicted merge in the specified paths.

  --conflict=<style>
    The same as --merge option above, but changes the way the conflicting hunks
    are presented, overriding the merge.conflictStyle configuration variable.
    Possible values are "merge" (default) and "diff3" (in addition to what is
    shown by "merge" style, shows the original contents).

  -p
  --patch
    Interactively select hunks in the difference between the <tree-ish> (or the
    index, if unspecified) and the working tree. The chosen hunks are then
    applied in reverse to the working tree (and if a <tree-ish> was specified,
    the index).

    This means that you can use git checkout -p to selectively discard edits
    from your current working tree. See the “Interactive Mode” section of
    git-add[1] to learn how to operate the --patch mode.

  --ignore-other-worktrees
    git checkout refuses when the wanted ref is already checked out by another
    worktree. This option makes it check the ref out anyway. In other words, the
    ref can be held by more than one worktree.

  <branch>
    Branch to checkout; if it refers to a branch (i.e., a name that, when
    prepended with "refs/heads/", is a valid ref), then that branch is checked
    out. Otherwise, if it refers to a valid commit, your HEAD becomes "detached"
    and you are no longer on any branch (see below for details).

    As a special case, the "@{-N}" syntax for the N-th last branch/commit checks
    out branches (instead of detaching). You may also specify - which is
    synonymous with "@{-1}".

    As a further special case, you may use "A...B" as a shortcut for the merge
    base of A and B if there is exactly one merge base. You can leave out at
    most one of A and B, in which case it defaults to HEAD.

  <new_branch>
    Name for the new branch.

  <start_point>
    The name of a commit at which to start the new branch; see git-branch[1] for
    details. Defaults to HEAD.

  <tree-ish>
    Tree to checkout from (when paths are given). If not specified, the index
    will be used.

------------------------------------------------------------------------------

Examples:
  1. The following sequence checks out the master branch, reverts the Makefile
     to two revisions back, deletes hello.c by mistake, and gets it back from
     the index.

     $ git checkout master             (1)
     $ git checkout master~2 Makefile  (2)
     $ rm -f hello.c
     $ git checkout hello.c            (3)

     1. switch branch
     2. take a file out of another commit
     3. restore hello.c from the index

     If you want to check out all C source files out of the index, you can say

     $ git checkout -- '*.c'

     Note the quotes around *.c. The file hello.c will also be checked out, even
     though it is no longer in the working tree, because the file globbing is
     used to match entries in the index (not in the working tree by the shell).

     If you have an unfortunate branch that is named hello.c, this step would be
     confused as an instruction to switch to that branch. You should instead
     write:

     $ git checkout -- hello.c

  2. After working in the wrong branch, switching to the correct branch would be
     done using:

     $ git checkout mytopic

     However, your "wrong" branch and correct "mytopic" branch may differ in
     files that you have modified locally, in which case the above checkout
     would fail like this:

     $ git checkout mytopic
     error: You have local changes to 'frotz'; not switching branches.

     You can give the -m flag to the command, which would try a three-way merge:

     $ git checkout -m mytopic
     Auto-merging frotz

     After this three-way merge, the local modifications are not registered in
     your index file, so git diff would show you what changes you made since the
     tip of the new branch.

  3. When a merge conflict happens during switching branches with the -m option,
     you would see something like this:

     $ git checkout -m mytopic
     Auto-merging frotz
     ERROR: Merge conflict in frotz
     fatal: merge program failed

     At this point, git diff shows the changes cleanly merged as in the previous
     example, as well as the changes in the conflicted files. Edit and resolve
     the conflict and mark it resolved with git add as usual:

     $ edit frotz
     $ git add frotz

EOF

exit 0

#!/usr/bin/env bash

cat<<EOF

Name:
  git-reset - Reset current HEAD to the specified state

------------------------------------------------------------------------------

Description:
  In the first and second form, copy entries from <tree-ish> to the index. In
  the third form, set the current branch head (HEAD) to <commit>, optionally
  modifying index and working tree to match. The <tree-ish>/<commit> defaults to
  HEAD in all forms.

  git reset [-q] [<tree-ish>] [--] <paths>...
    This form resets the index entries for all <paths> to their state at
    <tree-ish>. (It does not affect the working tree or the current branch.)

    This means that git reset <paths> is the opposite of git add <paths>.

    After running git reset <paths> to update the index entry, you can use
    git-checkout[1] to check the contents out of the index to the working tree.
    Alternatively, using git-checkout[1] and specifying a commit, you can copy
    the contents of a path out of a commit to the index and to the working tree
    in one go.

  git reset (--patch | -p) [<tree-ish>] [--] [<paths>...]
    Interactively select hunks in the difference between the index and
    <tree-ish> (defaults to HEAD). The chosen hunks are applied in reverse to
    the index.

    This means that git reset -p is the opposite of git add -p, i.e. you can use
    it to selectively reset hunks. See the “Interactive Mode” section of
    git-add[1] to learn how to operate the --patch mode.

  git reset [<mode>] [<commit>]
    This form resets the current branch head to <commit> and possibly updates
    the index (resetting it to the tree of <commit>) and the working tree
    depending on <mode>. If <mode> is omitted, defaults to "--mixed". The <mode>
    must be one of the following:

    --soft
      Does not touch the index file or the working tree at all (but resets the
      head to <commit>, just like all modes do). This leaves all your changed
      files "Changes to be committed", as git status would put it.

    --mixed
      Resets the index but not the working tree (i.e., the changed files are
      preserved but not marked for commit) and reports what has not been
      updated. This is the default action.

      If -N is specified, removed paths are marked as intent-to-add (see
      git-add).

    --hard
      Resets the index and working tree. Any changes to tracked files in the
      working tree since <commit> are discarded.

    --merge
      Resets the index and updates the files in the working tree that are
      different between <commit> and HEAD, but keeps those which are different
      between the index and working tree (i.e. which have changes which have not
      been added). If a file that is different between <commit> and the index
      has unstaged changes, reset is aborted.

      In other words, --merge does something like a git read-tree -u -m
      <commit>, but carries forward unmerged index entries.

    --keep
      Resets index entries and updates files in the working tree that are
      different between <commit> and HEAD. If a file that is different between
      <commit> and HEAD has local changes, reset is aborted.

  If you want to undo a commit other than the latest on a branch, git-revert
  is your friend.

------------------------------------------------------------------------------

Syntax:
  git reset [-q] [<tree-ish>] [--] <paths>...
  git reset (--patch | -p) [<tree-ish>] [--] [<paths>...
  git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<commit>]

------------------------------------------------------------------------------

Options:
  -q
  --quiet
    Be quiet, only report errors.

------------------------------------------------------------------------------

Examples:
  Undo add

  $ edit                                     (1)
  $ git add frotz.c filfre.c
  $ mailx                                    (2)
  $ git reset                                (3)
  $ git pull git://info.example.com/ nitfol  (4)

  1. You are happily working on something, and find the changes in these files are
     in good order. You do not want to see them when you run "git diff", because
     you plan to work on other files and changes with these files are
     distracting.

  2. Somebody asks you to pull, and the changes sounds worthy of merging.

  3. However, you already dirtied the index (i.e. your index does not match the
     HEAD commit). But you know the pull you are going to make does not affect
     frotz.c or filfre.c, so you revert the index changes for these two files.
     Your changes in working tree remain there.

  4. Then you can pull and merge, leaving frotz.c and filfre.c changes still in
     the working tree.


  Undo a commit and redo

  $ git commit ...
  $ git reset --soft HEAD^      (1)
  $ edit                        (2)
  $ git commit -a -c ORIG_HEAD  (3)

  1. This is most often done when you remembered what you just committed is
     incomplete, or you misspelled your commit message, or both. Leaves working
     tree as it was before "reset".

  2. Make corrections to working tree files.

  3. "reset" copies the old head to .git/ORIG_HEAD; redo the commit by starting
     with its log message. If you do not need to edit the message further, you
     can give -C option instead.

  See also the --amend option to git-commit.


  Undo a commit, making it a topic branch

  $ git branch topic/wip     (1)
  $ git reset --hard HEAD~3  (2)
  $ git checkout topic/wip   (3)

  1. You have made some commits, but realize they were premature to be in the
     "master" branch. You want to continue polishing them in a topic branch, so
     create "topic/wip" branch off of the current HEAD.

  2. Rewind the master branch to get rid of those three commits.

  3. Switch to "topic/wip" branch and keep working.


  Undo commits permanently

  $ git commit ...
  $ git reset --hard HEAD~3   (1)

  1. The last three commits (HEAD, HEAD^, and HEAD~2) were bad and you do not
     want to ever see them again. Do not do this if you have already given these
     commits to somebody else. (See the "RECOVERING FROM UPSTREAM REBASE"
     section in git-rebase[1] for the implications of doing so.)


  Undo a merge or pull

  $ git pull                         (1)
  Auto-merging nitfol
  CONFLICT (content): Merge conflict in nitfol
  Automatic merge failed; fix conflicts and then commit the result.
  $ git reset --hard                 (2)
  $ git pull . topic/branch          (3)
  Updating from 41223... to 13134...
  Fast-forward
  $ git reset --hard ORIG_HEAD       (4)

  1. Try to update from the upstream resulted in a lot of conflicts; you were
     not ready to spend a lot of time merging right now, so you decide to do
     that later.

  2. "pull" has not made merge commit, so "git reset --hard" which is a synonym
     for "git reset --hard HEAD" clears the mess from the index file and the
     working tree.

  3. Merge a topic branch into the current branch, which resulted in
     a fast-forward.

  4. But you decided that the topic branch is not ready for public consumption
     yet. "pull" or "merge" always leaves the original tip of the current branch
     in ORIG_HEAD, so resetting hard to it brings your index file and the
     working tree back to that state, and resets the tip of the branch to that
     commit.


  Undo a merge or pull inside a dirty working tree

  $ git pull                         (1)
  Auto-merging nitfol
  Merge made by recursive.
  nitfol                |   20 +++++----
  ...
  $ git reset --merge ORIG_HEAD      (2)

  1. Even if you may have local modifications in your working tree, you can
     safely say "git pull" when you know that the change in the other branch
     does not overlap with them.

  2. After inspecting the result of the merge, you may find that the change in
     the other branch is unsatisfactory. Running "git reset --hard ORIG_HEAD"
     will let you go back to where you were, but it will discard your local
     changes, which you do not want. "git reset --merge" keeps your local
     changes.


  Interrupted workflow

  Suppose you are interrupted by an urgent fix request while you are in the
  middle of a large change. The files in your working tree are not in any shape
  to be committed yet, but you need to get to the other branch for a quick
  bugfix.

  $ git checkout feature ;# you were working in "feature" branch and
  $ work work work       ;# got interrupted
  $ git commit -a -m "snapshot WIP"                 (1)
  $ git checkout master
  $ fix fix fix
  $ git commit ;# commit with real log
  $ git checkout feature
  $ git reset --soft HEAD^ ;# go back to WIP state  (2)
  $ git reset                                       (3)

  1. This commit will get blown away so a throw-away log message is OK.

  2. This removes the WIP commit from the commit history, and sets your working
     tree to the state just before you made that snapshot.

  3. At this point the index file still has all the WIP changes you committed as
     snapshot WIP. This updates the index to show your WIP files as uncommitted.

  See also git-stash.


  Reset a single file in the index

  Suppose you have added a file to your index, but later decide you do not want
  to add it to your commit. You can remove the file from the index while keeping
  your changes with git reset.

  $ git reset -- frotz.c                      (1)
  $ git commit -m "Commit files in index"     (2)
  $ git add frotz.c                           (3)

  1. This removes the file from the index while keeping it in the working
     directory.

  2. This commits all other changes in the index.

  3. Adds the file to the index again.


  Keep changes in working tree while discarding some previous commits

  Suppose you are working on something and you commit it, and then you continue
  working a bit more, but now you think that what you have in your working tree
  should be in another branch that has nothing to do with what you committed
  previously. You can start a new branch and reset it while keeping the changes
  in your working tree.

  $ git tag start
  $ git checkout -b branch1
  $ edit
  $ git commit ...                            (1)
  $ edit
  $ git checkout -b branch2                   (2)
  $ git reset --keep start                    (3)

  1. This commits your first edits in branch1.

  2. In the ideal world, you could have realized that the earlier commit did not
     belong to the new topic when you created and switched to branch2 (i.e. "git
     checkout -b branch2 start"), but nobody is perfect.

  3. But you can use "reset --keep" to remove the unwanted commit after you
     switched to "branch2".

EOF

exit 0

#!/usr/bin/env bash

cat<<EOF

Name:
  git-fetch - Download objects and refs from another repository

------------------------------------------------------------------------------

Description:
  Fetch branches and/or tags (collectively, "refs") from one or more other
  repositories, along with the objects necessary to complete their histories.
  Remote-tracking branches are updated (see the description of <refspec> below
  for ways to control this behavior).

  By default, any tag that points into the histories being fetched is also
  fetched; the effect is to fetch tags that point at branches that you are
  interested in. This default behavior can be changed by using the --tags or
  --no-tags options or by configuring remote.<name>.tagOpt. By using a refspec
  that fetches tags explicitly, you can fetch tags that do not point into
  branches you are interested in as well.

  git fetch can fetch from either a single named repository or URL, or from
  several repositories at once if <group> is given and there is
  a remotes.<group> entry in the configuration file. (See git-config[1]).

  When no remote is specified, by default the origin remote will be used, unless
  there’s an upstream branch configured for the current branch.

  The names of refs that are fetched, together with the object names they point
  at, are written to .git/FETCH_HEAD. This information may be used by scripts or
  other git commands, such as git-pull.

------------------------------------------------------------------------------

Syntax:
  git fetch [<options>] [<repository> [<refspec>...]]
  git fetch [<options>] <group>
  git fetch --multiple [<options>] [(<repository> | <group>)...]
  git fetch --all [<options>]

------------------------------------------------------------------------------

Options:
  --all
    Fetch all remotes.

  -a
  --append
    Append ref names and object names of fetched refs to the existing contents
    of .git/FETCH_HEAD. Without this option old data in .git/FETCH_HEAD will be
    overwritten.

  --depth=<depth>
    Limit fetching to the specified number of commits from the tip of each
    remote branch history. If fetching to a shallow repository created by git
    clone with --depth=<depth> option (see git-clone[1]), deepen or shorten the
    history to the specified number of commits. Tags for the deepened commits
    are not fetched.

  --unshallow
    If the source repository is complete, convert a shallow repository to
    a complete one, removing all the limitations imposed by shallow
    repositories.

    If the source repository is shallow, fetch as much as possible so that the
    current repository has the same history as the source repository.

  --update-shallow
    By default when fetching from a shallow repository, git fetch refuses refs
    that require updating .git/shallow. This option updates .git/shallow and
    accept such refs.

  --dry-run
    Show what would be done, without making any changes.

  -f
  --force
    When git fetch is used with <rbranch>:<lbranch> refspec, it refuses to
    update the local branch <lbranch> unless the remote branch <rbranch> it
    fetches is a descendant of <lbranch>. This option overrides that check.

  -k
  --keep
    Keep downloaded pack.

  --multiple
    Allow several <repository> and <group> arguments to be specified. No
    <refspec>s may be specified.

  -p
  --prune
    After fetching, remove any remote-tracking references that no longer exist
    on the remote. Tags are not subject to pruning if they are fetched only
    because of the default tag auto-following or due to a --tags option.
    However, if tags are fetched due to an explicit refspec (either on the
    command line or in the remote configuration, for example if the remote was
    cloned with the --mirror option), then they are also subject to pruning.

  -n
  --no-tags
    By default, tags that point at objects that are downloaded from the remote
    repository are fetched and stored locally. This option disables this
    automatic tag following. The default behavior for a remote may be specified
    with the remote.<name>.tagOpt setting. See git-config[1].

  --refmap=<refspec>
    When fetching refs listed on the command line, use the specified refspec
    (can be given more than once) to map the refs to remote-tracking branches,
    instead of the values of remote.*.fetch configuration variables for the
    remote repository. See section on "Configured Remote-tracking Branches" for
    details.

  -t
  --tags
    Fetch all tags from the remote (i.e., fetch remote tags refs/tags/* into
    local tags with the same name), in addition to whatever else would otherwise
    be fetched. Using this option alone does not subject tags to pruning, even
    if --prune is used (though tags may be pruned anyway if they are also the
      destination of an explicit refspec; see --prune).

  --recurse-submodules[=yes|on-demand|no]
    This option controls if and under what conditions new commits of populated
    submodules should be fetched too. It can be used as a boolean option to
    completely disable recursion when set to no or to unconditionally recurse
    into all populated submodules when set to yes, which is the default when
    this option is used without any value. Use on-demand to only recurse into
    a populated submodule when the superproject retrieves a commit that updates
    the submodule’s reference to a commit that isn’t already in the local
    submodule clone.

  --no-recurse-submodules
    Disable recursive fetching of submodules (this has the same effect as using
    the --recurse-submodules=no option).

  --submodule-prefix=<path>
    Prepend <path> to paths printed in informative messages such as "Fetching
    submodule foo". This option is used internally when recursing over
    submodules.

  --recurse-submodules-default=[yes|on-demand]
    This option is used internally to temporarily provide a non-negative default
    value for the --recurse-submodules option. All other methods of configuring
    fetch’s submodule recursion (such as settings in gitmodules[5] and
    git-config[1]) override this option, as does specifying
    --[no-]recurse-submodules directly.

  -u
  --update-head-ok
    By default git fetch refuses to update the head which corresponds to the
    current branch. This flag disables the check. This is purely for the
    internal use for git pull to communicate with git fetch, and unless you are
    implementing your own Porcelain you are not supposed to use it.

  --upload-pack <upload-pack>
    When given, and the repository to fetch from is handled by git fetch-pack,
    --exec=<upload-pack> is passed to the command to specify non-default path
    for the command run on the other end.

  -q
  --quiet
    Pass --quiet to git-fetch-pack and silence any other internally used git
    commands. Progress is not reported to the standard error stream.

  -v
  --verbose
    Be verbose.

  --progress
    Progress status is reported on the standard error stream by default when it
    is attached to a terminal, unless -q is specified. This flag forces progress
    status even if the standard error stream is not directed to a terminal.

  <repository>
    The "remote" repository that is the source of a fetch or pull operation.
    This parameter can be either a URL (see the section GIT URLS below) or the
    name of a remote (see the section REMOTES below).

  <group>
    A name referring to a list of repositories as the value of remotes.<group>
    in the configuration file. (See git-config[1]).

  <refspec>
    Specifies which refs to fetch and which local refs to update. When no
    <refspec>s appear on the command line, the refs to fetch are read from
    remote.<repository>.fetch variables instead (see CONFIGURED REMOTE-TRACKING
    BRANCHES below).

    The format of a <refspec> parameter is an optional plus +, followed by the
    source ref <src>, followed by a colon :, followed by the destination ref
    <dst>. The colon can be omitted when <dst> is empty.

    tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>; it requests
    fetching everything up to the given tag.

    The remote ref that matches <src> is fetched, and if <dst> is not empty
    string, the local ref that matches it is fast-forwarded using <src>. If the
    optional plus + is used, the local ref is updated even if it does not result
    in a fast-forward update.

    Note  When the remote branch you want to fetch is known to be rewound and
          rebased regularly, it is expected that its new tip will not be
          descendant of its previous tip (as stored in your remote-tracking
          branch the last time you fetched). You would want to use the + sign to
          indicate non-fast-forward updates will be needed for such branches.
          There is no way to determine or declare that a branch will be made
          available in a repository with this behavior; the pulling user simply
          must know this is the expected usage pattern for a branch.

------------------------------------------------------------------------------

Examples:
  Update the remote-tracking branches:

  $ git fetch origin

  The above command copies all branches from the remote refs/heads/ namespace
  and stores them to the local refs/remotes/origin/ namespace, unless the
  branch.<name>.fetch option is used to specify a non-default refspec.

  Using refspecs explicitly:

  $ git fetch origin +pu:pu maint:tmp

  This updates (or creates, as necessary) branches pu and tmp in the local
  repository by fetching from the branches (respectively) pu and maint from the
  remote repository.

  The pu branch will be updated even if it is does not fast-forward, because it
  is prefixed with a plus sign; tmp will not be.

  Peek at a remote’s branch, without configuring the remote in your local
  repository:

  $ git fetch git://git.kernel.org/pub/scm/git/git.git maint
  $ git log FETCH_HEAD

  The first command fetches the maint branch from the repository at
  git://git.kernel.org/pub/scm/git/git.git and the second command uses
  FETCH_HEAD to examine the branch with git-log[1]. The fetched objects will
  eventually be removed by git’s built-in housekeeping.

EOF

exit 0
